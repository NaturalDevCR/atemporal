{"version":3,"sources":["../src/index.ts","../src/TemporalUtils.ts","../src/TemporalWrapper.ts"],"sourcesContent":["// src/index.ts\n\n/**\n * @file This is the main entry point for the 'atemporal' library.\n * It sets up the main factory function, attaches static utility methods,\n * and handles the plugin system, making it the central hub for all functionality.\n */\n\n// Import the Temporal polyfill to ensure the API is available in all environments.\nimport '@js-temporal/polyfill';\n\n// [FIX] Re-import `Temporal` to handle the \"now\" case explicitly and safely.\nimport { Temporal } from '@js-temporal/polyfill';\nimport { TemporalWrapper } from './TemporalWrapper';\nimport { TemporalUtils } from './TemporalUtils';\nimport type { DateInput, Plugin, AtemporalFactory, AtemporalFunction } from './types';\n\n// Re-export the main wrapper class and utility types for direct use by consumers.\nexport { TemporalWrapper as Atemporal };\nexport type { DateInput, TimeUnit, SettableUnit, Plugin } from './types';\n\n/**\n * The core factory function for creating atemporal instances.\n * It can be called with various date inputs or with no arguments to get the current time.\n *\n * The function is fully typed by the `AtemporalFunction` type, so JSDoc param/returns are not needed.\n */\nconst atemporalFn: AtemporalFunction = (input?: DateInput, timeZone?: string) => {\n    // If the input is already an atemporal instance, clone it or change its timezone.\n    if (input instanceof TemporalWrapper) {\n        return timeZone ? input.timeZone(timeZone) : input.clone();\n    }\n\n    // [FIX] Handle the `undefined` case explicitly to satisfy the stricter type signature\n    // of `TemporalWrapper.from`. This resolves the TypeScript error.\n    if (input === undefined) {\n        // When no input is provided, create an instance for the current moment.\n        // We create the valid Temporal object here before passing it to the wrapper.\n        const nowTemporal = Temporal.Now.zonedDateTimeISO(timeZone || TemporalUtils.defaultTimeZone);\n        return TemporalWrapper.from(nowTemporal);\n    }\n\n    // At this point, `input` is guaranteed to be a valid `DateInput` type, so the call is safe.\n    return TemporalWrapper.from(input, timeZone);\n};\n\n// Augment the core function with static properties to create the final factory object.\n// This pattern allows calling `atemporal()` as a function while also accessing utils like `atemporal.isValid()`.\nconst atemporal = atemporalFn as AtemporalFactory;\n\n/**\n * Checks if a given input can be parsed into a valid date.\n * The function signature is inferred from `TemporalUtils.isValid`.\n */\natemporal.isValid = TemporalUtils.isValid;\n\n/**\n * Sets the default locale for all new atemporal instances. Used for formatting.\n * The function signature is inferred from `TemporalUtils.setDefaultLocale`.\n */\natemporal.setDefaultLocale = TemporalUtils.setDefaultLocale;\n\n/**\n * Sets the default IANA time zone for all new atemporal instances.\n * The function signature is inferred from `TemporalUtils.setDefaultTimeZone`.\n */\natemporal.setDefaultTimeZone = TemporalUtils.setDefaultTimeZone;\n\n/**\n * Gets the currently configured default locale.\n * The function signature is inferred from `TemporalUtils.getDefaultLocale`.\n */\natemporal.getDefaultLocale = TemporalUtils.getDefaultLocale;\n\n/**\n * Extends atemporal's functionality with a plugin.\n * The function signature is defined by its implementation.\n */\natemporal.extend = (plugin: Plugin, options) => {\n    plugin(TemporalWrapper, atemporal, options);\n};\n\n// Export the final, augmented factory function as the default export of the library.\nexport default atemporal;","// src/TemporalUtils.ts\n\n/**\n * @file This file provides a collection of low-level, static utility functions\n * for creating and manipulating Temporal objects. It serves as the internal\n * engine for the atemporal library, handling parsing, formatting, and comparisons.\n */\n\nimport { Temporal } from '@js-temporal/polyfill';\nimport type { DateInput, TimeUnit } from './types';\n\nexport class TemporalUtils {\n    // Private static properties to hold the global default settings.\n    private static _defaultTimeZone = 'UTC';\n    private static _defaultLocale = 'en-US';\n\n    /**\n     * Sets the default locale for all new atemporal instances. Used for formatting.\n     */\n    static setDefaultLocale(code: string) {\n        TemporalUtils._defaultLocale = code;\n    }\n\n    /**\n     * Gets the currently configured default locale.\n     */\n    static getDefaultLocale(): string {\n        return TemporalUtils._defaultLocale;\n    }\n\n    /**\n     * Sets the default IANA time zone for all new atemporal instances.\n     * It validates the time zone identifier before setting it.\n     */\n    static setDefaultTimeZone(tz: string) {\n        try {\n            // Validate the time zone by attempting to use it in a formatter.\n            // This is the standard way to check if a time zone is supported.\n            new Intl.DateTimeFormat('en-US', { timeZone: tz });\n            TemporalUtils._defaultTimeZone = tz;\n        } catch (e) {\n            throw new Error(`Invalid time zone: ${tz}`);\n        }\n    }\n\n    /**\n     * Gets the currently configured default time zone.\n     */\n    static get defaultTimeZone() {\n        return TemporalUtils._defaultTimeZone;\n    }\n\n    /**\n     * [REFACTOR FINAL Y DEFINITIVO] The core parsing engine, rewritten for clarity and robustness.\n     * Each input type is handled in a self-contained block that returns directly.\n     * The string parsing logic is now more defensive.\n     */\n    static from(input?: DateInput, timeZone?: string): Temporal.ZonedDateTime {\n        const tz = timeZone || TemporalUtils.defaultTimeZone;\n\n        if (input === undefined || input === null) {\n            return Temporal.Now.zonedDateTimeISO(tz);\n        }\n\n        // Handle objects that are already Temporal types or our wrapper\n        if (input instanceof Temporal.ZonedDateTime) {\n            return timeZone && input.timeZoneId !== timeZone ? input.withTimeZone(timeZone) : input;\n        }\n        if (typeof input === 'object' && 'raw' in input && (input as any).raw instanceof Temporal.ZonedDateTime) {\n            const raw = (input as any).raw as Temporal.ZonedDateTime;\n            return timeZone && raw.timeZoneId !== timeZone ? raw.withTimeZone(timeZone) : raw;\n        }\n        if (input instanceof Temporal.PlainDateTime) {\n            return input.toZonedDateTime(tz);\n        }\n\n        // Handle standard JavaScript Date\n        if (input instanceof Date) {\n            return Temporal.Instant.fromEpochMilliseconds(input.getTime()).toZonedDateTimeISO(tz);\n        }\n\n        // Handle string inputs with a more robust strategy\n        if (typeof input === 'string') {\n            try {\n                // STRATEGY 1: Try parsing as an Instant. This is the most robust way for\n                // full ISO strings that contain timezone information (like 'Z' or offsets).\n                // This will correctly handle the MOCK_NOW_ISO case.\n                const instant = Temporal.Instant.from(input);\n                const zdt = instant.toZonedDateTimeISO(tz);\n                // If a *different* timezone was requested, apply it.\n                return timeZone && tz !== zdt.timeZoneId ? zdt.withTimeZone(timeZone) : zdt;\n            } catch (e) {\n                try {\n                    // STRATEGY 2: If it's not an Instant, it might be a \"plain\" date string\n                    // without timezone info (e.g., \"2023-10-27 10:00:00\").\n                    const pdt = Temporal.PlainDateTime.from(input);\n                    return pdt.toZonedDateTime(tz);\n                } catch (e2) {\n                    // If both parsing attempts fail, the string is truly invalid.\n                    throw new Error(`Invalid date string: ${input}`);\n                }\n            }\n        }\n\n        // Handle number inputs (as epoch milliseconds)\n        if (typeof input === 'number') {\n            return Temporal.Instant.fromEpochMilliseconds(input).toZonedDateTimeISO(tz);\n        }\n\n        // If the input type is none of the above, it's unsupported.\n        throw new Error(`Unsupported date input type: ${typeof input}`);\n    }\n\n    /**\n     * Converts a Temporal.ZonedDateTime object back to a legacy JavaScript Date.\n     */\n    static toDate(temporal: Temporal.ZonedDateTime): Date {\n        return new Date(temporal.epochMilliseconds);\n    }\n\n    /**\n     * Calculates the difference between two dates in a specified unit.\n     */\n    static diff(a: DateInput, b: DateInput, unit: TimeUnit = 'millisecond'): number {\n        const d1 = TemporalUtils.from(a);\n        const d2 = TemporalUtils.from(b);\n\n        type TotalUnit = 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';\n\n        // Use the robust `since().total()` method for ALL units for calendar-aware accuracy.\n        return d1.since(d2).total({ unit: unit as TotalUnit, relativeTo: d1 });\n    }\n\n    /**\n     * Checks if date `a` is before date `b`.\n     */\n    static isBefore(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === -1;\n    }\n\n    /**\n     * Checks if date `a` is after date `b`.\n     */\n    static isAfter(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === 1;\n    }\n\n    /**\n     * Checks if a date `a` is between two other dates, `b` and `c`.\n     */\n    static isBetween(a: DateInput, b: DateInput, c: DateInput, inclusivity: '()' | '[]' | '(]' | '[)' = '[]'): boolean {\n        const date = TemporalUtils.from(a);\n        const start = TemporalUtils.from(b);\n        const end = TemporalUtils.from(c);\n\n        const compareWithStart = Temporal.ZonedDateTime.compare(date, start);\n        const compareWithEnd = Temporal.ZonedDateTime.compare(date, end);\n\n        const isAfterStart = inclusivity[0] === '['\n            ? compareWithStart >= 0 // a >= start\n            : compareWithStart > 0;  // a > start\n\n        const isBeforeEnd = inclusivity[1] === ']'\n            ? compareWithEnd <= 0 // a <= end\n            : compareWithEnd < 0;   // a < end\n\n        return isAfterStart && isBeforeEnd;\n    }\n\n    /**\n     * Checks if date `a` is the same instant in time as date `b`.\n     */\n    static isSame(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === 0;\n    }\n\n    /**\n     * Checks if date `a` is on the same calendar day as date `b`, ignoring time and timezone.\n     */\n    static isSameDay(a: DateInput, b: DateInput): boolean {\n        return TemporalUtils.from(a).toPlainDate().equals(TemporalUtils.from(b).toPlainDate());\n    }\n\n    /**\n     * Checks if a given input can be parsed into a valid date without throwing an error.\n     */\n    static isValid(input: any): boolean {\n        try {\n            TemporalUtils.from(input);\n            return true;\n        } catch (e) {\n            return false;\n        }\n    }\n}","/**\n * @file This file defines the TemporalWrapper class, which is the public-facing,\n * chainable, and immutable interface for the atemporal library. It wraps the\n * native Temporal.ZonedDateTime object to provide a more ergonomic API.\n */\n\nimport { Temporal } from '@js-temporal/polyfill';\nimport { TemporalUtils } from './TemporalUtils';\nimport type {DateInput, TimeUnit, SettableUnit, FormatTokenMap} from './types';\n\n// ... (las funciones auxiliares getDurationUnit y createTokenReplacements no cambian) ...\nfunction getDurationUnit(unit: TimeUnit): string {\n    if (unit === 'millisecond') return 'milliseconds';\n    return `${unit}s`;\n}\n\nfunction createTokenReplacements(instance: TemporalWrapper, locale?: string): FormatTokenMap {\n    return {\n        YYYY: () => instance.year.toString(),\n        YY: () => instance.year.toString().slice(-2),\n        MM: () => instance.month.toString().padStart(2, '0'),\n        M: () => instance.month.toString(),\n        DD: () => instance.day.toString().padStart(2, '0'),\n        D: () => instance.day.toString(),\n        HH: () => instance.hour.toString().padStart(2, '0'),\n        H: () => instance.hour.toString(),\n        mm: () => instance.minute.toString().padStart(2, '0'),\n        m: () => instance.minute.toString(),\n        ss: () => instance.second.toString().padStart(2, '0'),\n        s: () => instance.second.toString(),\n        dddd: () => instance.dayOfWeekName,\n        ddd: () => instance.raw.toLocaleString(locale || TemporalUtils.getDefaultLocale(), { weekday: 'short' }),\n        // [NUEVO] Añadimos los tokens de zona horaria\n        Z: () => instance.raw.offset, // e.g., +01:00\n        ZZ: () => instance.raw.offset.replace(':', ''), // e.g., +0100\n    };\n}\n\n\nexport class TemporalWrapper {\n    private readonly _datetime: Temporal.ZonedDateTime | null;\n    private readonly _isValid: boolean;\n\n    // [CAMBIO] El constructor ahora es privado para controlar la creación de instancias.\n    private constructor(input: DateInput, timeZone?: string) {\n        try {\n            this._datetime = TemporalUtils.from(input, timeZone);\n            this._isValid = true;\n        } catch (e) {\n            this._datetime = null;\n            this._isValid = false;\n        }\n    }\n\n    /**\n     * [NUEVO] Método de fábrica público para crear instancias.\n     * Este es ahora el punto de entrada principal.\n     */\n    static from(input: DateInput, tz?: string): TemporalWrapper {\n        return new TemporalWrapper(input, tz);\n    }\n\n    /**\n     * [NUEVO] Un método estático privado para crear una instancia desde un ZonedDateTime ya existente.\n     * Esto es más eficiente y claro que pasar por la lógica de parsing completa.\n     */\n    private static _fromZonedDateTime(dateTime: Temporal.ZonedDateTime): TemporalWrapper {\n        // Usamos Object.create para instanciar sin llamar al constructor y sus validaciones.\n        const wrapper = Object.create(TemporalWrapper.prototype);\n        wrapper._datetime = dateTime;\n        wrapper._isValid = true;\n        return wrapper;\n    }\n\n    /**\n     * [MODIFICADO] _cloneWith ahora usa el método estático directo y más eficiente.\n     */\n    private _cloneWith(newDateTime: Temporal.ZonedDateTime): TemporalWrapper {\n        return TemporalWrapper._fromZonedDateTime(newDateTime);\n    }\n\n    // --- El resto de la clase sigue igual, pero aquí la incluyo completa por claridad ---\n\n    isValid(): boolean {\n        return this._isValid;\n    }\n\n    get datetime(): Temporal.ZonedDateTime {\n        if (!this._isValid || !this._datetime) {\n            throw new Error(\"Cannot perform operations on an invalid Atemporal object.\");\n        }\n        return this._datetime;\n    }\n\n    timeZone(tz: string): TemporalWrapper {\n        if (!this.isValid()) return this;\n        // Aquí sí creamos una nueva instancia pasando por el constructor,\n        // ya que withTimeZone puede fallar si la zona es inválida.\n        return new TemporalWrapper(this.datetime.withTimeZone(tz));\n    }\n\n    add(value: number, unit: TimeUnit): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const duration = { [getDurationUnit(unit)]: value };\n        const newDate = this.datetime.add(duration);\n        return this._cloneWith(newDate);\n    }\n\n    subtract(value: number, unit: TimeUnit): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const duration = { [getDurationUnit(unit)]: value };\n        const newDate = this.datetime.subtract(duration);\n        return this._cloneWith(newDate);\n    }\n\n    set(unit: SettableUnit, value: number): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const newDate = this.datetime.with({ [unit]: value });\n        return this._cloneWith(newDate);\n    }\n\n    /**\n     * ...\n     * Note: `startOf('week')` assumes the week starts on Monday (ISO 8601 standard).\n     */\n    startOf(unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second'): TemporalWrapper {\n        if (!this.isValid()) return this;\n        switch (unit) {\n            case 'year': {\n                const newDateTime = this.datetime.with({ month: 1, day: 1 }).startOfDay();\n                return this._cloneWith(newDateTime);\n            }\n            case 'month': {\n                const newDateTime = this.datetime.with({ day: 1 }).startOfDay();\n                return this._cloneWith(newDateTime);\n            }\n            case 'week': {\n                // dayOfWeek is 1 for Monday and 7 for Sunday.\n                const dayOfWeek = this.datetime.dayOfWeek;\n                const daysToSubtract = dayOfWeek - 1;\n                const newDateTime = this.datetime.subtract({ days: daysToSubtract });\n                return this._cloneWith(newDateTime.startOfDay());\n            }\n            case 'day':\n                return this._cloneWith(this.datetime.startOfDay());\n            case 'hour':\n            case 'minute':\n            case 'second':\n                const newDate = this.datetime.round({ smallestUnit: unit, roundingMode: 'floor' });\n                return this._cloneWith(newDate);\n        }\n    }\n\n    endOf(unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second'): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const start = this.startOf(unit);\n        const nextStart = start.add(1, unit);\n        return nextStart.subtract(1, 'millisecond');\n    }\n\n    clone(): TemporalWrapper {\n        if (!this.isValid()) return this;\n        return this._cloneWith(this.datetime);\n    }\n\n    get(unit: SettableUnit): number {\n        if (!this.isValid()) return NaN;\n        return this.datetime[unit];\n    }\n\n    // --- Getters ---\n    get year(): number { return this.isValid() ? this.datetime.year : NaN; }\n    get month(): number { return this.isValid() ? this.datetime.month : NaN; }\n    get day(): number { return this.isValid() ? this.datetime.day : NaN; }\n    get dayOfWeekName(): string {\n        if (!this.isValid()) return 'Invalid Date';\n        const locale = TemporalUtils.getDefaultLocale();\n        return this.datetime.toLocaleString(locale, { weekday: 'long' });\n    }\n    get hour(): number { return this.isValid() ? this.datetime.hour : NaN; }\n    get minute(): number { return this.isValid() ? this.datetime.minute : NaN; }\n    get second(): number { return this.isValid() ? this.datetime.second : NaN; }\n    get millisecond(): number { return this.isValid() ? this.datetime.millisecond : NaN; }\n    get quarter(): number { return this.isValid() ? Math.ceil(this.datetime.month / 3) : NaN; }\n    get weekOfYear(): number { return this.isValid() ? this.datetime.weekOfYear! : NaN; }\n\n    // --- Formatters ---\n    format(formatString: string): string;\n    format(options?: Intl.DateTimeFormatOptions, localeCode?: string): string;\n    format(templateOrOptions?: string | Intl.DateTimeFormatOptions, localeCode?: string): string {\n        if (!this.isValid()) {\n            return 'Invalid Date';\n        }\n\n        if (typeof templateOrOptions === 'string') {\n            const formatString = templateOrOptions;\n            const replacements = createTokenReplacements(this, localeCode);\n            const tokenRegex = /YYYY|YY|MM|M|DD|D|HH|H|mm|m|ss|s|dddd|ddd|Z|ZZ/g;\n\n            return formatString.replace(tokenRegex, match => {\n                if (match in replacements) {\n                    return (replacements)[match]();\n                }\n                return match;\n            });\n        }\n\n        const options = templateOrOptions as Intl.DateTimeFormatOptions;\n        const locale = localeCode || TemporalUtils.getDefaultLocale();\n\n        // [FIX] You cannot mix `dateStyle`/`timeStyle` with component options like `year`.\n        // We must check if the user provided style options and use them exclusively if they exist.\n        if (options && ('dateStyle' in options || 'timeStyle' in options)) {\n            // If style options are present, use them directly without our defaults.\n            return new Intl.DateTimeFormat(locale, {\n                timeZone: this.datetime.timeZoneId,\n                ...options\n            }).format(this.toDate());\n        }\n\n        // If no style options are provided, then we can safely use our component defaults.\n        const defaultOptions: Intl.DateTimeFormatOptions = {\n            year: 'numeric', month: '2-digit', day: '2-digit',\n            hour: '2-digit', minute: '2-digit', second: '2-digit'\n        };\n\n        return new Intl.DateTimeFormat(locale, {\n            timeZone: this.datetime.timeZoneId,\n            ...defaultOptions,\n            ...options // User can still override specific components, e.g., { hour: undefined }\n        }).format(this.toDate());\n    }\n\n    // --- Comparison & Conversion Methods ---\n    diff(other: DateInput, unit: TimeUnit = 'millisecond'): number {\n        if (!this.isValid()) return NaN;\n        try {\n            return TemporalUtils.diff(this.datetime, other, unit);\n        } catch {\n            return NaN;\n        }\n    }\n\n    toDate(): Date {\n        if (!this.isValid()) return new Date(NaN);\n        return TemporalUtils.toDate(this.datetime);\n    }\n\n    toString(): string {\n        if (!this.isValid()) return 'Invalid Date';\n        return this.datetime.toString();\n    }\n\n    get raw(): Temporal.ZonedDateTime {\n        return this.datetime;\n    }\n\n    isBefore(other: DateInput): boolean {\n        if (!this.isValid()) return false;\n        try {\n            return TemporalUtils.isBefore(this.datetime, other);\n        } catch {\n            return false;\n        }\n    }\n\n    isAfter(other: DateInput): boolean {\n        if (!this.isValid()) return false;\n        try {\n            return TemporalUtils.isAfter(this.datetime, other);\n        } catch {\n            return false;\n        }\n    }\n\n    isBetween(start: DateInput, end: DateInput, inclusivity: '()' | '[]' | '(]' | '[)' = '[]'): boolean {\n        if (!this.isValid()) return false;\n        try {\n            return TemporalUtils.isBetween(this.datetime, start, end, inclusivity);\n        } catch (e) {\n            return false;\n        }\n    }\n\n    isSame(otherDate: DateInput, unit?: 'year' | 'month' | 'day'): boolean {\n        if (!this.isValid()) return false;\n        try {\n            const otherDateTime = TemporalUtils.from(otherDate, this.datetime.timeZoneId);\n            switch (unit) {\n                case 'year':\n                    return this.datetime.year === otherDateTime.year;\n                case 'month':\n                    return this.datetime.year === otherDateTime.year &&\n                        this.datetime.month === otherDateTime.month;\n                case 'day':\n                    return this.datetime.toPlainDate().equals(otherDateTime.toPlainDate());\n                default:\n                    return this.datetime.epochMilliseconds === otherDateTime.epochMilliseconds;\n            }\n        } catch {\n            return false;\n        }\n    }\n\n    isSameDay(other: DateInput): boolean {\n        if (!this.isValid()) return false;\n        try {\n            return TemporalUtils.isSameDay(this.datetime, other);\n        } catch {\n            return false;\n        }\n    }\n\n    isLeapYear(): boolean {\n        if (!this.isValid()) return false;\n        return this.datetime.inLeapYear;\n    }\n}"],"mappings":"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","names":["import_polyfill"]}