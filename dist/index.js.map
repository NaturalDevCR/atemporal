{"version":3,"sources":["../src/index.ts","../src/TemporalUtils.ts","../src/TemporalWrapper.ts"],"sourcesContent":["import '@js-temporal/polyfill';\n\nimport {Temporal} from \"@js-temporal/polyfill\";\n\nimport { TemporalWrapper } from './TemporalWrapper';\nimport { TemporalUtils } from './TemporalUtils';\nimport type { DateInput, Plugin, AtemporalFactory, AtemporalFunction } from './types';\n\nexport { TemporalWrapper as Atemporal };\nexport type { DateInput, TimeUnit, SettableUnit, Plugin } from './types';\n\n// La función 'wrap' ahora vive aquí dentro de nuestra función principal.\nconst atemporalFn: AtemporalFunction = (input?: DateInput, timeZone?: string) => {\n    if (input instanceof TemporalWrapper) {\n        return timeZone ? input.timeZone(timeZone) : input;\n    }\n\n    // --- LA SOLUCIÓN ESTÁ AQUÍ ---\n    // Si el usuario llama a atemporal() sin argumentos, 'input' será undefined.\n    // En ese caso, queremos devolver la fecha y hora actuales.\n    if (input === undefined) {\n        // Usamos la API nativa de Temporal para obtener la fecha y hora actuales\n        // en la zona horaria por defecto que el usuario haya configurado.\n        const now = Temporal.Now.zonedDateTimeISO(TemporalUtils.defaultTimeZone);\n        return new TemporalWrapper(now);\n    }\n\n    // Si 'input' no es undefined, TypeScript ahora sabe que es un DateInput válido\n    // y podemos pasarlo directamente al constructor.\n    return new TemporalWrapper(input, timeZone);\n};\n\n// Construimos el objeto final\nconst atemporal = atemporalFn as AtemporalFactory;\n\natemporal.isValid = TemporalUtils.isValid;\natemporal.setDefaultLocale = TemporalUtils.setDefaultLocale;\natemporal.setDefaultTimeZone = TemporalUtils.setDefaultTimeZone;\natemporal.getDefaultLocale = TemporalUtils.getDefaultLocale;\n\natemporal.extend = (plugin: Plugin, options) => {\n    plugin(TemporalWrapper, atemporal, options);\n};\n\nexport default atemporal;","import { Temporal } from '@js-temporal/polyfill';\n// import { TemporalWrapper } from './TemporalWrapper';\nimport type { DateInput, TimeUnit } from './types';\n\nexport class TemporalUtils {\n    private static _defaultTimeZone = 'UTC';\n    private static _defaultLocale = 'en-US';\n\n    static setDefaultLocale(code: string) {\n        TemporalUtils._defaultLocale = code;\n    }\n\n    static getDefaultLocale(): string {\n        return TemporalUtils._defaultLocale;\n    }\n\n    static setDefaultTimeZone(tz: string) {\n        try {\n            new Intl.DateTimeFormat('en-US', { timeZone: tz });\n            TemporalUtils._defaultTimeZone = tz;\n        } catch (e) {\n            throw new Error(`Invalid time zone: ${tz}`);\n        }\n    }\n\n    static get defaultTimeZone() {\n        return TemporalUtils._defaultTimeZone;\n    }\n\n    static from(input: DateInput, timeZone: string = TemporalUtils.defaultTimeZone): Temporal.ZonedDateTime {\n        // La comprobación 'instanceof TemporalWrapper' se movió a index.ts, pero dejarla aquí no hace daño.\n        // if (input instanceof TemporalWrapper) {\n        //     return input.raw;\n        // }\n        if (typeof input === 'object' && input !== null && 'raw' in input) {\n            // Sabemos que es un TemporalWrapper, así que accedemos a su propiedad .raw\n            return (input as any).raw;\n        }\n\n        // NO debe haber ninguna comprobación de 'toDate()' aquí.\n\n        if (input instanceof Temporal.ZonedDateTime) {\n            return input.withTimeZone(timeZone);\n        }\n        if (input instanceof Temporal.PlainDateTime) {\n            return input.toZonedDateTime(timeZone);\n        }\n        if (input instanceof Date) {\n            return Temporal.Instant.fromEpochMilliseconds(input.getTime()).toZonedDateTimeISO(timeZone);\n        }\n        if (typeof input === 'string') {\n            try {\n                // Intenta parsear como ZonedDateTime (espera offset/zona horaria en el string)\n                return Temporal.ZonedDateTime.from(input).withTimeZone(timeZone);\n            } catch (e) {\n                // Si falla, puede ser un string sin zona horaria (PlainDateTime)\n                try {\n                    const plainDateTime = Temporal.PlainDateTime.from(input);\n                    return plainDateTime.toZonedDateTime(timeZone);\n                } catch (e2) {\n                    // Si ambos fallan, el string es inválido.\n                    throw new Error(`Invalid date string: ${input}`);\n                }\n            }\n        }\n        throw new Error('Unsupported date input');\n    }\n\n    static toDate(temporal: Temporal.ZonedDateTime): Date {\n        return new Date(temporal.epochMilliseconds);\n    }\n\n    // static format(\n    //     input: DateInput,\n    //     options: Intl.DateTimeFormatOptions = {\n    //         year: 'numeric', month: '2-digit', day: '2-digit',\n    //         hour: '2-digit', minute: '2-digit', second: '2-digit'\n    //     },\n    //     localeCode: string = TemporalUtils._defaultLocale\n    // ): string {\n    //     const dt = TemporalUtils.from(input);\n    //     return new Intl.DateTimeFormat(localeCode, {\n    //         timeZone: dt.timeZoneId,\n    //         ...options\n    //     }).format(TemporalUtils.toDate(dt));\n    // }\n\n    static diff(a: DateInput, b: DateInput, unit: TimeUnit = 'millisecond'): number {\n        const d1 = TemporalUtils.from(a);\n        const d2 = TemporalUtils.from(b);\n\n        // Ayudamos a TypeScript a entender que nuestra 'unit' es compatible.\n        type TotalUnit = 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';\n        return d1.since(d2).total({ unit: unit as TotalUnit, relativeTo: d1 });\n    }\n\n    static isBefore(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === -1;\n    }\n\n    static isAfter(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === 1;\n    }\n\n    static isSame(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === 0;\n    }\n\n    static isSameDay(a: DateInput, b: DateInput): boolean {\n        return TemporalUtils.from(a).toPlainDate().equals(TemporalUtils.from(b).toPlainDate());\n    }\n\n    static isValid(input: any): boolean {\n        try {\n            // Intentamos procesar el input con nuestro método principal.\n            // Si no lanza un error, el input es válido.\n            TemporalUtils.from(input);\n            return true;\n        } catch (e) {\n            // Si 'from' lanza cualquier error, el input es inválido.\n            return false;\n        }\n    }\n}","import { Temporal } from '@js-temporal/polyfill';\nimport { TemporalUtils } from './TemporalUtils';\nimport type { DateInput, TimeUnit, SettableUnit } from './types';\n\n// Función auxiliar para pluralizar unidades, se mantiene igual.\nfunction getDurationUnit(unit: TimeUnit): string {\n    if (unit === 'millisecond') return 'milliseconds';\n    return `${unit}s`;\n}\n\nexport class TemporalWrapper {\n    // --- CAMBIO 1: Estado Interno ---\n    // _datetime ahora puede ser null si la fecha es inválida.\n    // _isValid guarda el estado de la instancia.\n    private readonly _datetime: Temporal.ZonedDateTime | null;\n    private readonly _isValid: boolean;\n\n    constructor(input: DateInput, timeZone: string = TemporalUtils.defaultTimeZone) {\n        // --- CAMBIO 2: El Constructor ahora es a prueba de errores ---\n        try {\n            // Intentamos crear la fecha como antes.\n            this._datetime = TemporalUtils.from(input, timeZone);\n            this._isValid = true;\n        } catch (e) {\n            // Si TemporalUtils.from lanza un error, lo capturamos.\n            // Marcamos la instancia como inválida y asignamos null.\n            this._datetime = null;\n            this._isValid = false;\n        }\n    }\n\n    // --- CAMBIO 3: El método `isValid` de instancia ---\n    /**\n     * Comprueba si la instancia de Atemporal representa una fecha y hora válidas.\n     * @returns {boolean} `true` si es válida, `false` en caso contrario.\n     */\n    isValid(): boolean {\n        return this._isValid;\n    }\n\n    // --- CAMBIO 4: Getter protegido para el objeto Temporal interno ---\n    // Este getter asegura que no intentemos operar sobre un objeto nulo.\n    // Los métodos públicos usarán `isValid()` para evitar llegar a este error.\n    get datetime(): Temporal.ZonedDateTime {\n        if (!this._isValid || !this._datetime) {\n            throw new Error(\"Cannot perform operations on an invalid Atemporal object.\");\n        }\n        return this._datetime;\n    }\n\n    // --- CAMBIO 5: Todos los métodos públicos ahora están protegidos ---\n    // A partir de aquí, cada método primero comprueba si la instancia es válida.\n\n    static from(input: DateInput, tz?: string) {\n        return new TemporalWrapper(input, tz);\n    }\n\n    timeZone(tz: string): TemporalWrapper {\n        if (!this.isValid()) return this; // Devuelve la misma instancia inválida\n        return new TemporalWrapper(this.datetime.withTimeZone(tz));\n    }\n\n    add(value: number, unit: TimeUnit): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const duration = { [getDurationUnit(unit)]: value };\n        const newDate = this.datetime.add(duration);\n        return new TemporalWrapper(newDate);\n    }\n\n    subtract(value: number, unit: TimeUnit): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const duration = { [getDurationUnit(unit)]: value };\n        const newDate = this.datetime.subtract(duration);\n        return new TemporalWrapper(newDate);\n    }\n\n    set(unit: SettableUnit, value: number): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const newDate = this.datetime.with({ [unit]: value });\n        return new TemporalWrapper(newDate);\n    }\n\n    startOf(unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second'): TemporalWrapper {\n        if (!this.isValid()) return this;\n        // La lógica interna no cambia, solo se protege la entrada.\n        switch (unit) {\n            case 'year': {\n                const pDate = this.datetime.toPlainDate().with({ month: 1, day: 1 });\n                return new TemporalWrapper(pDate.toZonedDateTime(this.datetime.timeZoneId));\n            }\n            case 'month': {\n                const pDate = this.datetime.toPlainDate().with({ day: 1 });\n                return new TemporalWrapper(pDate.toZonedDateTime(this.datetime.timeZoneId));\n            }\n            case 'week': {\n                const dayOfWeek = this.datetime.dayOfWeek;\n                const daysToSubtract = dayOfWeek - 1;\n                const pDate = this.datetime.subtract({ days: daysToSubtract }).toPlainDate();\n                return new TemporalWrapper(pDate.toZonedDateTime(this.datetime.timeZoneId));\n            }\n            case 'day':\n                return new TemporalWrapper(this.datetime.startOfDay());\n            case 'hour':\n            case 'minute':\n            case 'second':\n                const newDate = this.datetime.round({ smallestUnit: unit, roundingMode: 'floor' });\n                return new TemporalWrapper(newDate);\n        }\n    }\n\n    endOf(unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second'): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const start = this.startOf(unit);\n        const nextStart = start.add(1, unit);\n        return nextStart.subtract(1, 'millisecond');\n    }\n\n    clone(): TemporalWrapper {\n        if (!this.isValid()) return this;\n        return new TemporalWrapper(this.datetime);\n    }\n\n    get(unit: SettableUnit): number {\n        if (!this.isValid()) return NaN;\n        return this.datetime[unit];\n    }\n\n    // Getters protegidos\n    get year(): number { return this.isValid() ? this.datetime.year : NaN; }\n    get month(): number { return this.isValid() ? this.datetime.month : NaN; }\n    get day(): number { return this.isValid() ? this.datetime.day : NaN; }\n    get dayOfWeekName(): string {\n        if (!this.isValid()) return 'Invalid Date';\n        const locale = TemporalUtils.getDefaultLocale();\n        return this.datetime.toLocaleString(locale, { weekday: 'long' });\n    }\n    get hour(): number { return this.isValid() ? this.datetime.hour : NaN; }\n    get minute(): number { return this.isValid() ? this.datetime.minute : NaN; }\n    get second(): number { return this.isValid() ? this.datetime.second : NaN; }\n    get millisecond(): number { return this.isValid() ? this.datetime.millisecond : NaN; }\n    get quarter(): number { return this.isValid() ? Math.ceil(this.datetime.month / 3) : NaN; }\n    get weekOfYear(): number { return this.isValid() ? this.datetime.weekOfYear! : NaN; }\n\n    format(options?: Intl.DateTimeFormatOptions, localeCode?: string): string {\n        if (!this.isValid()) return 'Invalid Date';\n\n        // La lógica ahora vive aquí, haciendo la clase más autocontenida.\n        const locale = localeCode || TemporalUtils.getDefaultLocale();\n        const defaultOptions: Intl.DateTimeFormatOptions = {\n            year: 'numeric', month: '2-digit', day: '2-digit',\n            hour: '2-digit', minute: '2-digit', second: '2-digit'\n        };\n\n        return new Intl.DateTimeFormat(locale, {\n            timeZone: this.datetime.timeZoneId,\n            ...defaultOptions,\n            ...options // Las opciones del usuario sobreescriben las por defecto\n        }).format(this.toDate());\n    }\n\n    diff(other: DateInput, unit: TimeUnit = 'millisecond'): number {\n        const otherAtemporal = new TemporalWrapper(other);\n        if (!this.isValid() || !otherAtemporal.isValid()) return NaN;\n        return TemporalUtils.diff(this.datetime, other, unit);\n    }\n\n    toDate(): Date {\n        if (!this.isValid()) return new Date(NaN); // Devuelve un objeto Date inválido estándar\n        return TemporalUtils.toDate(this.datetime);\n    }\n\n    toString(): string {\n        if (!this.isValid()) return 'Invalid Date';\n        return this.datetime.toString();\n    }\n\n    get raw(): Temporal.ZonedDateTime {\n        // Este es el único lugar donde lanzamos un error si se intenta acceder al objeto raw de una instancia inválida.\n        return this.datetime;\n    }\n\n    isBefore(other: DateInput): boolean {\n        const otherAtemporal = new TemporalWrapper(other);\n        if (!this.isValid() || !otherAtemporal.isValid()) return false;\n        return TemporalUtils.isBefore(this.datetime, other);\n    }\n\n    isAfter(other: DateInput): boolean {\n        const otherAtemporal = new TemporalWrapper(other);\n        if (!this.isValid() || !otherAtemporal.isValid()) return false;\n        return TemporalUtils.isAfter(this.datetime, other);\n    }\n\n    isSame(otherDate: DateInput, unit?: 'year' | 'month' | 'day'): boolean {\n        const other = new TemporalWrapper(otherDate);\n        if (!this.isValid() || !other.isValid()) return false;\n\n        switch (unit) {\n            case 'year':\n                return this.datetime.year === other.datetime.year;\n            case 'month':\n                return this.datetime.year === other.datetime.year &&\n                    this.datetime.month === other.datetime.month;\n            case 'day':\n                return this.datetime.toPlainDate().equals(other.datetime.toPlainDate());\n            default:\n                return this.datetime.epochMilliseconds === other.datetime.epochMilliseconds;\n        }\n    }\n\n    isSameDay(other: DateInput): boolean {\n        const otherAtemporal = new TemporalWrapper(other);\n        if (!this.isValid() || !otherAtemporal.isValid()) return false;\n        return TemporalUtils.isSameDay(this.datetime, other);\n    }\n\n    isLeapYear(): boolean {\n        if (!this.isValid()) return false;\n        return this.datetime.inLeapYear;\n    }\n}"],"mappings":"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","names":["import_polyfill"]}