{"version":3,"sources":["../src/index.ts","../src/TemporalUtils.ts","../src/TemporalWrapper.ts"],"sourcesContent":["/**\n * @file This is the main entry point for the 'atemporal' library.\n * It sets up the main factory function, attaches static utility methods,\n * and handles the plugin system, making it the central hub for all functionality.\n */\n\n// Import the Temporal polyfill to ensure the API is available in all environments.\nimport '@js-temporal/polyfill';\n\nimport { Temporal } from \"@js-temporal/polyfill\";\nimport { TemporalWrapper } from './TemporalWrapper';\nimport { TemporalUtils } from './TemporalUtils';\nimport type { DateInput, Plugin, AtemporalFactory, AtemporalFunction } from './types';\n\n// Re-export the main wrapper class and utility types for direct use by consumers.\nexport { TemporalWrapper as Atemporal };\nexport type { DateInput, TimeUnit, SettableUnit, Plugin } from './types';\n\n/**\n * The core factory function for creating atemporal instances.\n * It can be called with various date inputs or with no arguments to get the current time.\n *\n * The function is fully typed by the `AtemporalFunction` type, so JSDoc param/returns are not needed.\n */\nconst atemporalFn: AtemporalFunction = (input?: DateInput, timeZone?: string) => {\n    // If the input is already an atemporal instance, clone it.\n    // If a new timezone is provided, apply it; otherwise, return the clone.\n    if (input instanceof TemporalWrapper) {\n        return timeZone ? input.timeZone(timeZone) : input;\n    }\n\n    // Handle the case where atemporal() is called without arguments.\n    if (input === undefined) {\n        // Create an instance representing the current moment in the configured default timezone.\n        const now = Temporal.Now.zonedDateTimeISO(TemporalUtils.defaultTimeZone);\n        return new TemporalWrapper(now);\n    }\n\n    // For all other valid inputs, pass them directly to the constructor.\n    // TypeScript knows 'input' is no longer undefined here, ensuring type safety.\n    return new TemporalWrapper(input, timeZone);\n};\n\n// Augment the core function with static properties to create the final factory object.\n// This pattern allows calling `atemporal()` as a function while also accessing utils like `atemporal.isValid()`.\nconst atemporal = atemporalFn as AtemporalFactory;\n\n/**\n * Checks if a given input can be parsed into a valid date.\n * The function signature is inferred from `TemporalUtils.isValid`.\n */\natemporal.isValid = TemporalUtils.isValid;\n\n/**\n * Sets the default locale for all new atemporal instances. Used for formatting.\n * The function signature is inferred from `TemporalUtils.setDefaultLocale`.\n */\natemporal.setDefaultLocale = TemporalUtils.setDefaultLocale;\n\n/**\n * Sets the default IANA time zone for all new atemporal instances.\n * The function signature is inferred from `TemporalUtils.setDefaultTimeZone`.\n */\natemporal.setDefaultTimeZone = TemporalUtils.setDefaultTimeZone;\n\n/**\n * Gets the currently configured default locale.\n * The function signature is inferred from `TemporalUtils.getDefaultLocale`.\n */\natemporal.getDefaultLocale = TemporalUtils.getDefaultLocale;\n\n/**\n * Extends atemporal's functionality with a plugin.\n * The function signature is defined by its implementation.\n */\natemporal.extend = (plugin: Plugin, options) => {\n    plugin(TemporalWrapper, atemporal, options);\n};\n\n// Export the final, augmented factory function as the default export of the library.\nexport default atemporal;","/**\n * @file This file provides a collection of low-level, static utility functions\n * for creating and manipulating Temporal objects. It serves as the internal\n * engine for the atemporal library, handling parsing, formatting, and comparisons.\n */\n\nimport { Temporal } from '@js-temporal/polyfill';\nimport type { DateInput, TimeUnit } from './types';\n\nexport class TemporalUtils {\n    // Private static properties to hold the global default settings.\n    private static _defaultTimeZone = 'UTC';\n    private static _defaultLocale = 'en-US';\n\n    /**\n     * Sets the default locale for all new atemporal instances. Used for formatting.\n     */\n    static setDefaultLocale(code: string) {\n        TemporalUtils._defaultLocale = code;\n    }\n\n    /**\n     * Gets the currently configured default locale.\n     */\n    static getDefaultLocale(): string {\n        return TemporalUtils._defaultLocale;\n    }\n\n    /**\n     * Sets the default IANA time zone for all new atemporal instances.\n     * It validates the time zone identifier before setting it.\n     */\n    static setDefaultTimeZone(tz: string) {\n        try {\n            // Validate the time zone by attempting to use it in a formatter.\n            // This is the standard way to check if a time zone is supported.\n            new Intl.DateTimeFormat('en-US', { timeZone: tz });\n            TemporalUtils._defaultTimeZone = tz;\n        } catch (e) {\n            throw new Error(`Invalid time zone: ${tz}`);\n        }\n    }\n\n    /**\n     * Gets the currently configured default time zone.\n     */\n    static get defaultTimeZone() {\n        return TemporalUtils._defaultTimeZone;\n    }\n\n    /**\n     * The core parsing engine. Converts any valid DateInput into a Temporal.ZonedDateTime object.\n     * This function is designed to be robust and handle various input formats.\n     */\n    static from(input: DateInput, timeZone: string = TemporalUtils.defaultTimeZone): Temporal.ZonedDateTime {\n        // Duck-typing check for an atemporal instance.\n        // This is more robust than `instanceof` across different module contexts.\n        if (typeof input === 'object' && input !== null && 'raw' in input) {\n            // It's a TemporalWrapper, so we can access its internal .raw property.\n            return (input as any).raw;\n        }\n\n        if (input instanceof Temporal.ZonedDateTime) {\n            return input.withTimeZone(timeZone);\n        }\n        if (input instanceof Temporal.PlainDateTime) {\n            return input.toZonedDateTime(timeZone);\n        }\n        if (input instanceof Date) {\n            return Temporal.Instant.fromEpochMilliseconds(input.getTime()).toZonedDateTimeISO(timeZone);\n        }\n        if (typeof input === 'string') {\n            try {\n                // First, attempt to parse as a ZonedDateTime (expects offset/timezone info).\n                return Temporal.ZonedDateTime.from(input).withTimeZone(timeZone);\n            } catch (e) {\n                // If that fails, it might be a plain string without timezone info.\n                try {\n                    const plainDateTime = Temporal.PlainDateTime.from(input);\n                    return plainDateTime.toZonedDateTime(timeZone);\n                } catch (e2) {\n                    // If both attempts fail, the string is invalid.\n                    throw new Error(`Invalid date string: ${input}`);\n                }\n            }\n        }\n        // If the input type is not supported, throw an error.\n        throw new Error('Unsupported date input');\n    }\n\n    /**\n     * Converts a Temporal.ZonedDateTime object back to a legacy JavaScript Date.\n     */\n    static toDate(temporal: Temporal.ZonedDateTime): Date {\n        return new Date(temporal.epochMilliseconds);\n    }\n\n    /**\n     * Calculates the difference between two dates in a specified unit.\n     */\n    static diff(a: DateInput, b: DateInput, unit: TimeUnit = 'millisecond'): number {\n        const d1 = TemporalUtils.from(a);\n        const d2 = TemporalUtils.from(b);\n\n        // The `total` method requires a more specific unit type than our `TimeUnit`.\n        // We use a type assertion to satisfy TypeScript.\n        type TotalUnit = 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second' | 'millisecond';\n        return d1.since(d2).total({ unit: unit as TotalUnit, relativeTo: d1 });\n    }\n\n    /**\n     * Checks if date `a` is before date `b`.\n     */\n    static isBefore(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === -1;\n    }\n\n    /**\n     * Checks if date `a` is after date `b`.\n     */\n    static isAfter(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === 1;\n    }\n\n    /**\n     * Checks if a date `a` is between two other dates, `b` and `c`.\n     * This is the low-level implementation.\n     */\n    static isBetween(a: DateInput, b: DateInput, c: DateInput, inclusivity: '()' | '[]' | '(]' | '[)' = '[]'): boolean {\n        const date = TemporalUtils.from(a);\n        const start = TemporalUtils.from(b);\n        const end = TemporalUtils.from(c);\n\n        // Compare returns -1 (a < b), 0 (a === b), or 1 (a > b)\n        const compareWithStart = Temporal.ZonedDateTime.compare(date, start);\n        const compareWithEnd = Temporal.ZonedDateTime.compare(date, end);\n\n        const isAfterStart = inclusivity[0] === '['\n            ? compareWithStart >= 0 // a >= start\n            : compareWithStart > 0;  // a > start\n\n        const isBeforeEnd = inclusivity[1] === ']'\n            ? compareWithEnd <= 0 // a <= end\n            : compareWithEnd < 0;   // a < end\n\n        return isAfterStart && isBeforeEnd;\n    }\n\n    /**\n     * Checks if date `a` is the same instant in time as date `b`.\n     */\n    static isSame(a: DateInput, b: DateInput): boolean {\n        return Temporal.ZonedDateTime.compare(TemporalUtils.from(a), TemporalUtils.from(b)) === 0;\n    }\n\n    /**\n     * Checks if date `a` is on the same calendar day as date `b`, ignoring time and timezone.\n     */\n    static isSameDay(a: DateInput, b: DateInput): boolean {\n        return TemporalUtils.from(a).toPlainDate().equals(TemporalUtils.from(b).toPlainDate());\n    }\n\n    /**\n     * Checks if a given input can be parsed into a valid date without throwing an error.\n     * This is used for the static `atemporal.isValid()` method.\n     */\n    static isValid(input: any): boolean {\n        try {\n            // Attempt to process the input with our main parsing function.\n            // If it doesn't throw, the input is considered valid.\n            TemporalUtils.from(input);\n            return true;\n        } catch (e) {\n            // If `from` throws any error, the input is invalid.\n            return false;\n        }\n    }\n}","/**\n * @file This file defines the TemporalWrapper class, which is the public-facing,\n * chainable, and immutable interface for the atemporal library. It wraps the\n * native Temporal.ZonedDateTime object to provide a more ergonomic API.\n */\n\nimport { Temporal } from '@js-temporal/polyfill';\nimport { TemporalUtils } from './TemporalUtils';\nimport type {DateInput, TimeUnit, SettableUnit, FormatTokenMap} from './types';\n\n/**\n * A private helper function to get the correct plural unit name required\n * by the Temporal.Duration object.\n */\nfunction getDurationUnit(unit: TimeUnit): string {\n    // 'millisecond' is a special case; the rest just need an 's'.\n    if (unit === 'millisecond') return 'milliseconds';\n    return `${unit}s`;\n}\n\n/**\n * Creates a map of supported formatting tokens to their replacement functions.\n * This is a private helper for the .format() method.\n * @param instance The TemporalWrapper instance to format.\n * @param locale An optional locale for localized tokens.\n */\nfunction createTokenReplacements(instance: TemporalWrapper, locale?: string): FormatTokenMap {\n    return {\n        YYYY: () => instance.year.toString(),\n        YY: () => instance.year.toString().slice(-2),\n        MM: () => instance.month.toString().padStart(2, '0'),\n        M: () => instance.month.toString(),\n        DD: () => instance.day.toString().padStart(2, '0'),\n        D: () => instance.day.toString(),\n        HH: () => instance.hour.toString().padStart(2, '0'),\n        H: () => instance.hour.toString(),\n        mm: () => instance.minute.toString().padStart(2, '0'),\n        m: () => instance.minute.toString(),\n        ss: () => instance.second.toString().padStart(2, '0'),\n        s: () => instance.second.toString(),\n        dddd: () => instance.dayOfWeekName,\n        // We need to access the raw datetime for this localized format\n        ddd: () => instance.raw.toLocaleString(locale || TemporalUtils.getDefaultLocale(), { weekday: 'short' }),\n    };\n}\n\nexport class TemporalWrapper {\n    // --- Internal State ---\n    // _datetime can be null if the input date was invalid.\n    // _isValid stores the validity state of the instance.\n    private readonly _datetime: Temporal.ZonedDateTime | null;\n    private readonly _isValid: boolean;\n\n    constructor(input: DateInput, timeZone: string = TemporalUtils.defaultTimeZone) {\n        // --- Error-Proof Constructor ---\n        try {\n            // Attempt to create the date using the low-level utility.\n            this._datetime = TemporalUtils.from(input, timeZone);\n            this._isValid = true;\n        } catch (e) {\n            // If TemporalUtils.from throws, we catch the error here.\n            // Instead of crashing, we mark the instance as invalid.\n            this._datetime = null;\n            this._isValid = false;\n        }\n    }\n\n    // --- Core API Methods ---\n\n    /**\n     * Checks if the atemporal instance represents a valid date and time.\n     * This is the primary way to handle potentially invalid date inputs gracefully.\n     */\n    isValid(): boolean {\n        return this._isValid;\n    }\n\n    /**\n     * A protected getter for the internal Temporal.ZonedDateTime object.\n     * This ensures that we don't accidentally try to operate on a null object.\n     * Public methods should use `isValid()` to avoid triggering this error.\n     */\n    get datetime(): Temporal.ZonedDateTime {\n        if (!this._isValid || !this._datetime) {\n            throw new Error(\"Cannot perform operations on an invalid Atemporal object.\");\n        }\n        return this._datetime;\n    }\n\n    /**\n     * A static factory method to create a new TemporalWrapper instance.\n     * Provides an alternative to calling the main factory function.\n     */\n    static from(input: DateInput, tz?: string) {\n        return new TemporalWrapper(input, tz);\n    }\n\n    /**\n     * Returns a new atemporal instance with a different time zone.\n     */\n    timeZone(tz: string): TemporalWrapper {\n        if (!this.isValid()) return this; // Return the same invalid instance\n        return new TemporalWrapper(this.datetime.withTimeZone(tz));\n    }\n\n    /**\n     * Returns a new atemporal instance with the specified amount of time added.\n     */\n    add(value: number, unit: TimeUnit): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const duration = { [getDurationUnit(unit)]: value };\n        const newDate = this.datetime.add(duration);\n        return new TemporalWrapper(newDate);\n    }\n\n    /**\n     * Returns a new atemporal instance with the specified amount of time subtracted.\n     */\n    subtract(value: number, unit: TimeUnit): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const duration = { [getDurationUnit(unit)]: value };\n        const newDate = this.datetime.subtract(duration);\n        return new TemporalWrapper(newDate);\n    }\n\n    /**\n     * Returns a new atemporal instance with a specific unit of time set to a new value.\n     */\n    set(unit: SettableUnit, value: number): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const newDate = this.datetime.with({ [unit]: value });\n        return new TemporalWrapper(newDate);\n    }\n\n    /**\n     * Returns a new atemporal instance set to the beginning of a specified unit of time.\n     */\n    startOf(unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second'): TemporalWrapper {\n        if (!this.isValid()) return this;\n        switch (unit) {\n            case 'year': {\n                const pDate = this.datetime.toPlainDate().with({ month: 1, day: 1 });\n                return new TemporalWrapper(pDate.toZonedDateTime(this.datetime.timeZoneId));\n            }\n            case 'month': {\n                const pDate = this.datetime.toPlainDate().with({ day: 1 });\n                return new TemporalWrapper(pDate.toZonedDateTime(this.datetime.timeZoneId));\n            }\n            case 'week': {\n                // Assuming ISO 8601 week start (Monday = 1).\n                const dayOfWeek = this.datetime.dayOfWeek;\n                const daysToSubtract = dayOfWeek - 1;\n                const pDate = this.datetime.subtract({ days: daysToSubtract }).toPlainDate();\n                return new TemporalWrapper(pDate.toZonedDateTime(this.datetime.timeZoneId));\n            }\n            case 'day':\n                return new TemporalWrapper(this.datetime.startOfDay());\n            case 'hour':\n            case 'minute':\n            case 'second':\n                const newDate = this.datetime.round({ smallestUnit: unit, roundingMode: 'floor' });\n                return new TemporalWrapper(newDate);\n        }\n    }\n\n    /**\n     * Returns a new atemporal instance set to the end of a specified unit of time.\n     */\n    endOf(unit: 'year' | 'month' | 'week' | 'day' | 'hour' | 'minute' | 'second'): TemporalWrapper {\n        if (!this.isValid()) return this;\n        const start = this.startOf(unit);\n        const nextStart = start.add(1, unit);\n        return nextStart.subtract(1, 'millisecond');\n    }\n\n    /**\n     * Returns a new, cloned instance of the atemporal object.\n     */\n    clone(): TemporalWrapper {\n        if (!this.isValid()) return this;\n        return new TemporalWrapper(this.datetime);\n    }\n\n    /**\n     * Gets a specific unit of time from the instance.\n     */\n    get(unit: SettableUnit): number {\n        if (!this.isValid()) return NaN;\n        return this.datetime[unit];\n    }\n\n    // --- Getters for common date parts ---\n    get year(): number { return this.isValid() ? this.datetime.year : NaN; }\n    get month(): number { return this.isValid() ? this.datetime.month : NaN; }\n    get day(): number { return this.isValid() ? this.datetime.day : NaN; }\n    get dayOfWeekName(): string {\n        if (!this.isValid()) return 'Invalid Date';\n        const locale = TemporalUtils.getDefaultLocale();\n        return this.datetime.toLocaleString(locale, { weekday: 'long' });\n    }\n    get hour(): number { return this.isValid() ? this.datetime.hour : NaN; }\n    get minute(): number { return this.isValid() ? this.datetime.minute : NaN; }\n    get second(): number { return this.isValid() ? this.datetime.second : NaN; }\n    get millisecond(): number { return this.isValid() ? this.datetime.millisecond : NaN; }\n    get quarter(): number { return this.isValid() ? Math.ceil(this.datetime.month / 3) : NaN; }\n    get weekOfYear(): number { return this.isValid() ? this.datetime.weekOfYear! : NaN; }\n\n\n    // --- Formatters ---\n    /**\n     * Formats the date into a string using a token-based template, similar to Day.js.\n     *\n     * @param formatString - A string with tokens (e.g., 'YYYY-MM-DD HH:mm:ss').\n     * @returns A formatted date string.\n     * @example\n     * atemporal().format('DD/MM/YYYY');\n     */\n    format(formatString: string): string;\n\n    /**\n     * Formats the date into a localized string using the native `Intl.DateTimeFormat` API.\n     *\n     * @param options - An object with `Intl.DateTimeFormat` formatting options.\n     * @param localeCode - Optional locale (e.g., 'es-CR') to override the default.\n     * @returns A formatted date string.\n     * @example\n     * atemporal().format({ dateStyle: 'full' }, 'es-ES');\n     */\n    format(options?: Intl.DateTimeFormatOptions, localeCode?: string): string;\n\n    /**\n     * Implementation of the format method.\n     */\n    format(templateOrOptions?: string | Intl.DateTimeFormatOptions, localeCode?: string): string {\n        if (!this.isValid()) {\n            return 'Invalid Date';\n        }\n\n        // --- Case 1: Token-based formatting (e.g. 'YYYY-MM-DD') ---\n        if (typeof templateOrOptions === 'string') {\n            const formatString = templateOrOptions;\n            const replacements = createTokenReplacements(this, localeCode);\n            const tokenRegex = /YYYY|YY|MM|M|DD|D|HH|H|mm|m|ss|s|dddd|ddd/g;\n\n            return formatString.replace(tokenRegex, match => {\n                if (match in replacements) {\n                    // We need to tell TypeScript that `match` is a valid key.\n                    return replacements[match]();\n                }\n                return match;\n            });\n        }\n\n\n        // --- Case 2: Intl.DateTimeFormat options object ---\n        const options = templateOrOptions;\n        const locale = localeCode || TemporalUtils.getDefaultLocale();\n        const defaultOptions: Intl.DateTimeFormatOptions = {\n            year: 'numeric', month: '2-digit', day: '2-digit',\n            hour: '2-digit', minute: '2-digit', second: '2-digit'\n        };\n\n        return new Intl.DateTimeFormat(locale, {\n            timeZone: this.datetime.timeZoneId,\n            ...defaultOptions,\n            ...options\n        }).format(this.toDate());\n    }\n\n\n    // --- Comparison Methods ---\n    /**\n     * Calculates the difference between this instance and another date.\n     */\n    diff(other: DateInput, unit: TimeUnit = 'millisecond'): number {\n        const otherAtemporal = new TemporalWrapper(other);\n        if (!this.isValid() || !otherAtemporal.isValid()) return NaN;\n        return TemporalUtils.diff(this.datetime, other, unit);\n    }\n\n    /**\n     * Converts the atemporal instance to a legacy JavaScript Date object.\n     */\n    toDate(): Date {\n        if (!this.isValid()) return new Date(NaN); // Return a standard invalid Date\n        return TemporalUtils.toDate(this.datetime);\n    }\n\n    /**\n     * Returns the full ISO 8601 string representation of the date.\n     */\n    toString(): string {\n        if (!this.isValid()) return 'Invalid Date';\n        return this.datetime.toString();\n    }\n\n    /**\n     * Provides direct, \"raw\" access to the underlying Temporal.ZonedDateTime object.\n     * This is the only getter that will throw an error if the instance is invalid.\n     */\n    get raw(): Temporal.ZonedDateTime {\n        return this.datetime;\n    }\n\n    /**\n     * Checks if this instance is before another date.\n     */\n    isBefore(other: DateInput): boolean {\n        const otherAtemporal = new TemporalWrapper(other);\n        if (!this.isValid() || !otherAtemporal.isValid()) return false;\n        return TemporalUtils.isBefore(this.datetime, other);\n    }\n\n    /**\n     * Checks if this instance is after another date.\n     */\n    isAfter(other: DateInput): boolean {\n        const otherAtemporal = new TemporalWrapper(other);\n        if (!this.isValid() || !otherAtemporal.isValid()) return false;\n        return TemporalUtils.isAfter(this.datetime, other);\n    }\n\n    /**\n     * Checks if the instance's date is between two other dates.\n     * @param start - The start date of the range.\n     * @param end - The end date of the range.\n     * @param inclusivity - A string indicating whether the start and end dates should be included.\n     * '[]' means inclusive on both ends (default).\n     * '()' means exclusive on both ends.\n     * '[)' means inclusive start, exclusive end.\n     * '(]' means exclusive start, inclusive end.\n     * @example\n     * atemporal('2025-01-15').isBetween('2025-01-10', '2025-01-20'); // true\n     * atemporal('2025-01-20').isBetween('2025-01-10', '2025-01-20', '[)'); // false\n     */\n    isBetween(start: DateInput, end: DateInput, inclusivity: '()' | '[]' | '(]' | '[)' = '[]'): boolean {\n        // The wrapper's only job is to manage validity and delegate.\n        if (!this.isValid()) {\n            return false;\n        }\n\n        // We don't need to check the validity of start/end here,\n        // because the constructor of atemporal handles it. If they are invalid,\n        // the call inside TemporalUtils.isBetween will fail gracefully\n        // or be handled by the isValid check in the wrapper.\n        // Let's delegate directly to the more performant utility function.\n        try {\n            return TemporalUtils.isBetween(this.datetime, start, end, inclusivity);\n        } catch (e) {\n            // If start or end are invalid inputs that TemporalUtils.from cannot parse,\n            // it will throw. We catch it and return false, which is the expected behavior.\n            return false;\n        }\n    }\n\n    /**\n     * Checks if this instance is the same as another date, optionally to a specific unit.\n     */\n    isSame(otherDate: DateInput, unit?: 'year' | 'month' | 'day'): boolean {\n        const other = new TemporalWrapper(otherDate);\n        if (!this.isValid() || !other.isValid()) return false;\n\n        switch (unit) {\n            case 'year':\n                return this.datetime.year === other.datetime.year;\n            case 'month':\n                return this.datetime.year === other.datetime.year &&\n                    this.datetime.month === other.datetime.month;\n            case 'day':\n                return this.datetime.toPlainDate().equals(other.datetime.toPlainDate());\n            default:\n                // Compares the exact instant in time.\n                return this.datetime.epochMilliseconds === other.datetime.epochMilliseconds;\n        }\n    }\n\n    /**\n     * Checks if this instance is on the same calendar day as another date.\n     */\n    isSameDay(other: DateInput): boolean {\n        const otherAtemporal = new TemporalWrapper(other);\n        if (!this.isValid() || !otherAtemporal.isValid()) return false;\n        return TemporalUtils.isSameDay(this.datetime, other);\n    }\n\n    /**\n     * Checks if the instance's year is a leap year.\n     */\n    isLeapYear(): boolean {\n        if (!this.isValid()) return false;\n        return this.datetime.inLeapYear;\n    }\n}"],"mappings":"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","names":["Temporal","Temporal"]}